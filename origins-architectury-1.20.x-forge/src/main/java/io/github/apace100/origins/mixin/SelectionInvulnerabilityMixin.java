package io.github.apace100.origins.mixin;

import io.github.apace100.origins.Origins;
import io.github.edwinmindcraft.calio.common.CalioConfig;
import io.github.edwinmindcraft.origins.api.OriginsAPI;
import io.github.edwinmindcraft.origins.api.capabilities.IOriginContainer;
import net.minecraft.core.Holder;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.tags.DamageTypeTags;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.player.Player;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

import java.util.stream.Collectors;

@Mixin(Entity.class)
public abstract class SelectionInvulnerabilityMixin {
	@Inject(at = @At("HEAD"), method = "isInvulnerableTo", cancellable = true)
	private void makeOriginInvulnerable(DamageSource damageSource, CallbackInfoReturnable<Boolean> cir) {
		if (!damageSource.is(DamageTypeTags.BYPASSES_INVULNERABILITY)) {
			Entity entity = (Entity) (Object) this;
			IOriginContainer.get(entity).ifPresent(container -> {
				if (!container.hasAllOrigins()) {
					cir.setReturnValue(true);
					if (CalioConfig.COMMON.logging.get()) {
						String s = OriginsAPI.getActiveLayers().stream()
								.filter(x -> !container.hasOrigin(x) && !x.value().empty((Player) entity))
								.map(layer -> "\"%s\" (Eligible: %s)".formatted(layer.key(), layer.value().origins((Player) entity).stream()
										.map(Holder::unwrapKey)
										.flatMap(x -> x.stream().map(ResourceKey::location).map(ResourceLocation::toString))
										.collect(Collectors.joining(","))))
								.collect(Collectors.joining(","));
						Origins.LOGGER.info("Player {} took damage while missing origins for layers: {0}", s);
					}
				}
			});
		}
	}
}
